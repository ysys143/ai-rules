---
description: 
globs: 
alwaysApply: false
---
# FastAPI Backend Design Guidelines

> **Note**: The domain examples used in this document (Account, Customer, Product, etc.) are for illustration purposes. Please modify them according to your specific use case and business domain.

This document defines core design principles and patterns for developing backend systems.
It is based on the requirements and design of an application project.

# Technology Stack and Basic Rules

## Technology Stack

**Framework:** FastAPI with Python 3.11+
**Key Dependencies:** FastAPI, SQLModel, Pydantic, asyncpg, pytest, uvicorn
**Core Principles:** Adherence to SOLID, DRY, KISS, YAGNI principles and OWASP security best practices

## Architecture Layer Rules

**Rule:** Clear layer separation and responsibility assignment

**Rationale:**
- Improved maintainability through separation of concerns
- Ensuring test independence
- Maximizing code reusability

#### Layer Responsibility Definition

```python
# 1. Router: Handles only request/response processing
from fastapi import APIRouter, Depends, HTTPException
from typing import List

router = APIRouter(prefix="/api/accounts", tags=["accounts"])

@router.post("/create", response_model=ApiResponse[AccountResponse])
async def create_account(
    request: AccountRequest,
    account_service: AccountService = Depends(get_account_service)
) -> ApiResponse[AccountResponse]:
    """Account creation endpoint"""
    # Only responsible for DTO conversion and service calls
    account_dto = convert_to_dto(request)
    result = await account_service.create_account(account_dto)
    return ApiResponse.success("Account created successfully.", convert_to_response(result))

# 2. Service Interface: Defines business logic
from abc import ABC, abstractmethod

class AccountService(ABC):
    @abstractmethod
    async def create_account(self, account_dto: AccountDTO) -> AccountDTO:
        pass
    
    @abstractmethod
    async def get_account(self, account_no: str) -> AccountDTO:
        pass

# 3. ServiceImpl: Implements business logic, uses Repository
class AccountServiceImpl(AccountService):
    def __init__(
        self,
        account_repository: AccountRepository,
        customer_service: CustomerService,
        product_service: ProductService,
        validation_service: AccountValidationService
    ):
        self.account_repository = account_repository
        self.customer_service = customer_service
        self.product_service = product_service
        self.validation_service = validation_service
    
    async def create_account(self, account_dto: AccountDTO) -> AccountDTO:
        """Multiple DB operations requiring transactions"""
        async with get_db_context() as session:
            # 1. Input validation
            await self.validation_service.validate_account_creation(account_dto)
            
            # 2. Check for duplicate accounts
            await self.validate_duplicate_account(account_dto.customer_no, account_dto.product_code)
            
            # 3. Verify customer existence
            customer = await self.customer_service.get_customer(account_dto.customer_no)
            
            # 4. Verify product existence
            product = await self.product_service.get_product(account_dto.product_code)
            
            # 5. Create account
            account = convert_to_entity(account_dto)
            account.account_no = await self.generate_account_number()
            saved_account = await self.account_repository.save(session, account)
            
            # 6. Register initial transaction
            await self.create_initial_transaction(session, saved_account)
            
            # Transaction is automatically committed by context manager
            return convert_to_dto(saved_account)
    
    async def validate_duplicate_account(self, customer_no: str, product_code: str):
        async with get_db_context() as session:
            exists = await self.account_repository.exists_by_customer_no_and_product_code(session, customer_no, product_code)
            if exists:
                raise ValidationException("An account with the same product already exists.")
    
    async def get_account(self, account_no: str) -> AccountDTO:
        """Read-only transaction"""
        async with get_db_context() as session:
            account = await self.account_repository.find_by_account_no_with_details(session, account_no)
            if not account:
                raise DataNotFoundException(f"Account not found: {account_no}")
            return convert_to_dto(account)
```

# Architecture Design Principles

## SOLID Principles Compliance

**Rule:** All service classes must strictly adhere to SOLID principles.

**Rationale:**
- Improved maintainability and extensibility
- Enhanced testability
- Maximized code reusability

#### Recommended Pattern: Single Responsibility Principle (SRP)

```python
# Correct example: Service responsible only for validation
class AccountValidationService:
    """
    Responsible only for account creation validation
    SRP: Single responsibility for validation logic only
    """
    async def validate_account_creation(self, account_dto: AccountDTO):
        await self.validate_required_fields(account_dto)
        await self.validate_field_formats(account_dto)
        await self.validate_business_rules(account_dto)
    
    async def validate_required_fields(self, account_dto: AccountDTO):
        # Required field validation logic
        pass

# Correct example: Service that only orchestrates account creation flow
class AccountServiceImpl(AccountService):
    def __init__(
        self,
        validation_service: AccountValidationService,
        customer_service: CustomerService,
        product_service: ProductService
    ):
        self.validation_service = validation_service
        self.customer_service = customer_service
        self.product_service = product_service
    
    async def create_account(self, account_dto: AccountDTO) -> AccountDTO:
        """
        Orchestrates only the overall flow of account creation process
        SRP: Single responsibility for business flow orchestration only
        """
        # 1. Validation (delegated to validation service)
        await self.validation_service.validate_account_creation(account_dto)
        
        # 2. Customer information verification (delegated to customer service)
        customer = await self.customer_service.get_customer(account_dto.customer_no)
        
        # 3. Product information verification (delegated to product service)
        product = await self.product_service.get_product(account_dto.product_code)
        
        # 4. Account creation processing
        return await self.create_account_entity(account_dto, customer, product)
```

## Layer Separation and Dependency Management

**Rule:** Clear separation between layers and adherence to dependency direction

**Rationale:**
- Minimized coupling
- Ensuring test independence
- Minimized change impact

#### Recommended Pattern: Layer-wise Responsibility Separation

```python
# Router Layer: Handles only HTTP request/response
from fastapi import APIRouter, Depends

router = APIRouter()

@router.post("/accounts")
async def create_account(
    request: AccountRequest,
    account_service: AccountService = Depends(get_account_service)
) -> ApiResponse[AccountResponse]:
    # Only responsible for DTO conversion and service calls
    account_dto = convert_to_dto(request)
    result = await account_service.create_account(account_dto)
    return ApiResponse.success("Account created.", convert_to_response(result))

# Service Layer: Handles business logic
class AccountServiceImpl(AccountService):
    # Implements business rules, manages transactions
    pass

# Repository Layer: Handles only data access
class AccountRepository:
    async def save(self, session: AsyncSession, account: Account) -> Account:
        # Only pure data CRUD operations
        pass
```

## Domain-Driven Design

**Rule:** Business domain-centered package structure

**Rationale:**
- Improved cohesion of business logic
- Better communication with domain experts
- Support for independent development by feature

#### Recommended Pattern: Domain-based Package Structure

```
app/
├── domain/
│   ├── account/
│   │   ├── router/
│   │   │   └── account_router.py
│   │   ├── service/
│   │   │   ├── account_service.py
│   │   │   ├── account_service_impl.py
│   │   │   ├── account_validation_service.py
│   │   │   └── masking_util_service.py
│   │   ├── repository/
│   │   │   └── account_repository.py
│   │   ├── model/
│   │   │   ├── account.py
│   │   │   └── account_transaction.py
│   │   └── schema/
│   │       ├── account_dto.py
│   │       ├── account_request.py
│   │       └── account_response.py
│   ├── customer/
│   │   ├── service/
│   │   │   ├── customer_service.py
│   │   │   └── customer_service_impl.py
│   │   ├── repository/
│   │   │   └── customer_repository.py
│   │   └── model/
│   │       └── customer.py
│   └── product/
│       ├── service/
│       │   ├── product_service.py
│       │   └── product_service_impl.py
│       ├── repository/
│       │   └── product_repository.py
│       └── model/
│           └── product.py
├── common/
│   ├── exception/
│   ├── util/
│   └── config/
└── main.py
```

# Entity Design Rules

## Entity Class Rules

**Rule:** Standardized SQLModel annotations and attribute definitions

**Rationale:**
- Consistent data modeling
- SQLAlchemy optimization
- Automatic validation

#### Recommended Pattern: Standard Entity Structure

```python
from sqlmodel import SQLModel, Field, Relationship
from datetime import datetime
from decimal import Decimal
from typing import Optional, List
from pydantic import field_validator, ConfigDict

# Import custom exceptions instead of redefining
from common.exceptions import ValidationException, DataNotFoundException

class Account(SQLModel, table=True):
    model_config = ConfigDict(
        validate_assignment=True,
        use_enum_values=True
    )
    
    __tablename__ = "tb_account"  # 소문자 snake_case로 통일
    
    account_no: Optional[str] = Field(default=None, primary_key=True, max_length=11)
    customer_no: str = Field(max_length=10, index=True)
    product_code: str = Field(max_length=6, index=True)
    identity_no: str = Field(max_length=13)  # National ID or SSN
    new_amount: Decimal = Field(decimal_places=0, ge=0, le=999999999999)
    
    # Relationship mapping uses LAZY loading by default
    customer: Optional["Customer"] = Relationship(back_populates="accounts")
    product: Optional["Product"] = Relationship(back_populates="accounts")
    transactions: List["AccountTransaction"] = Relationship(back_populates="account")
    
    created_date: datetime = Field(default_factory=datetime.now)
    updated_date: Optional[datetime] = Field(default=None)
    
    @field_validator('product_code')
    @classmethod
    def validate_product_code(cls, v):
        if not v.isdigit() or len(v) != 6:
            raise ValidationException('Product code must be exactly 6 digits')
        return v
    
    @field_validator('identity_no')
    @classmethod
    def validate_identity_no(cls, v):
        if not v.isdigit() or len(v) != 13:
            raise ValidationException('Identity number must be 13 digits')
        return v
```

# Repository Design Rules

## Repository Interface Rules

**Rule:** Standard Repository pattern based on SQLAlchemy

**Rationale:**
- Leveraging SQLAlchemy optimization
- Preventing N+1 problems
- Consistent data access patterns

#### Recommended Pattern: Standard Repository Structure

```python
from abc import ABC, abstractmethod
from sqlalchemy.ext.asyncio import AsyncSession
from sqlalchemy import select, exists
from sqlalchemy.orm import selectinload
from typing import Optional, List

class AccountRepository(ABC):
    @abstractmethod
    async def save(self, session: AsyncSession, account: Account) -> Account:
        pass
    
    @abstractmethod
    async def find_by_account_no_with_details(self, session: AsyncSession, account_no: str) -> Optional[Account]:
        pass

class AccountRepositoryImpl(AccountRepository):
    async def save(self, session: AsyncSession, account: Account) -> Account:
        session.add(account)
        await session.flush()
        await session.refresh(account)
        return account
    
    async def find_by_customer_no_order_by_created_date(self, session: AsyncSession, customer_no: str) -> List[Account]:
        """Query accounts by customer number (ordered by creation date desc)"""
        stmt = select(Account).where(Account.customer_no == customer_no).order_by(Account.created_date.desc())
        result = await session.execute(stmt)
        return result.scalars().all()
    
    async def find_by_account_no_with_details(self, session: AsyncSession, account_no: str) -> Optional[Account]:
        """Using EntityGraph to prevent N+1 problems"""
        stmt = (
            select(Account)
            .options(
                selectinload(Account.customer),
                selectinload(Account.product),
                selectinload(Account.transactions)
            )
            .where(Account.account_no == account_no)
        )
        result = await session.execute(stmt)
        return result.scalar_one_or_none()
    
    async def exists_by_customer_no_and_product_code(self, session: AsyncSession, customer_no: str, product_code: str) -> bool:
        """Existence check (using EXISTS instead of COUNT for performance optimization)"""
        stmt = select(exists().where(Account.customer_no == customer_no, Account.product_code == product_code))
        result = await session.execute(stmt)
        return result.scalar()
```

# Service Layer Design

## Service/ServiceImpl Separation Pattern

**Rule:** Interface and implementation separation for extensibility

**Rationale:**
- Easy implementation replacement
- Convenience for creating test mock objects
- Support for multiple implementations

#### Recommended Pattern: Service Interface Separation

```python
# Service Interface: Defines business logic contracts
from abc import ABC, abstractmethod

class AccountService(ABC):
    @abstractmethod
    async def create_account(self, account_dto: AccountDTO) -> AccountDTO:
        pass
    
    @abstractmethod
    async def get_account(self, account_no: str) -> AccountDTO:
        pass
    
    @abstractmethod
    async def get_accounts_by_customer(self, customer_no: str) -> List[AccountDTO]:
        pass
    
    @abstractmethod
    async def validate_duplicate_account(self, customer_no: str, product_code: str):
        pass

# ServiceImpl: Actual business logic implementation
class AccountServiceImpl(AccountService):
    def __init__(
        self,
        account_repository: AccountRepository,
        customer_service: CustomerService,
        product_service: ProductService,
        validation_service: AccountValidationService
    ):
        self.account_repository = account_repository
        self.customer_service = customer_service
        self.product_service = product_service
        self.validation_service = validation_service
    
    async def create_account(self, account_dto: AccountDTO) -> AccountDTO:
        """Multiple DB operations requiring transactions"""
        async with get_db_context() as session:
            # 1. Input validation
            await self.validation_service.validate_account_creation(account_dto)
            
            # 2. Check for duplicate accounts
            await self.validate_duplicate_account(account_dto.customer_no, account_dto.product_code)
            
            # 3. Verify customer existence
            customer = await self.customer_service.get_customer(account_dto.customer_no)
            
            # 4. Verify product existence
            product = await self.product_service.get_product(account_dto.product_code)
            
            # 5. Create account
            account = convert_to_entity(account_dto)
            account.account_no = await self.generate_account_number()
            saved_account = await self.account_repository.save(session, account)
            
            # 6. Register initial transaction
            await self.create_initial_transaction(session, saved_account)
            
            # Transaction is automatically committed by context manager
            return convert_to_dto(saved_account)
    
    async def validate_duplicate_account(self, customer_no: str, product_code: str):
        async with get_db_context() as session:
            exists = await self.account_repository.exists_by_customer_no_and_product_code(session, customer_no, product_code)
            if exists:
                raise ValidationException("An account with the same product already exists.")
    
    async def get_account(self, account_no: str) -> AccountDTO:
        """Read-only transaction"""
        async with get_db_context() as session:
            account = await self.account_repository.find_by_account_no_with_details(session, account_no)
            if not account:
                raise DataNotFoundException(f"Account not found: {account_no}")
            return convert_to_dto(account)
```

## DTO Design Rules

**Rule:** Pydantic-based immutable DTOs and validation logic

**Rationale:**
- Safety through immutability
- Concise code writing
- Compile-time safety

#### Recommended Pattern: Pydantic-based DTO

```python
from pydantic import BaseModel, field_validator, Field, ConfigDict
from decimal import Decimal
from datetime import date
from typing import Optional

class AccountDTO(BaseModel):
    model_config = ConfigDict(
        frozen=True,  # Immutability guarantee
        validate_assignment=True,
        extra='forbid'
    )
    
    account_no: Optional[str] = None
    customer_no: str = Field(..., min_length=1, max_length=10)
    product_code: str = Field(..., min_length=6, max_length=6)
    identity_no: str = Field(..., min_length=13, max_length=13)
    new_amount: Decimal = Field(..., ge=0)
    
    @field_validator('product_code')
    @classmethod
    def validate_product_code(cls, v):
        if not v.isdigit() or len(v) != 6:
            raise ValidationException("Product code must be exactly 6 digits.")
        return v
    
    @field_validator('identity_no')
    @classmethod
    def validate_identity_no(cls, v):
        if not v.isdigit() or len(v) != 13:
            raise ValidationException("Identity number must be 13 digits.")
        return v
    
    @field_validator('new_amount')
    @classmethod
    def validate_amount_sum(cls, v, values):
        """Business rule validation"""
        cash_amount = values.get('cash_amount', 0)
        transfer_amount = values.get('transfer_amount', 0)
        if v != cash_amount + transfer_amount:
            raise ValidationException("New amount must equal the sum of cash amount and transfer amount.")
        return v
    
    @field_validator('password_confirm')
    @classmethod
    def validate_password_match(cls, v, values):
        """Password confirmation validation"""
        password = values.get('password')
        if password and v != password:
            raise ValidationException("Passwords do not match.")
        return v
```

# API Response Standardization

## Standard ApiResponse Structure

**Rule:** All API responses use standardized ApiResponse structure

**Rationale:**
- Consistent API response format
- Client processing convenience
- Standardized error handling

#### Recommended Pattern: Standard Response Structure

```python
from typing import TypeVar, Generic, Optional
from pydantic import BaseModel

T = TypeVar('T')

class ApiResponse(BaseModel, Generic[T]):
    result: str  # SUCCESS or ERROR
    message: str  # Success/failure message
    data: Optional[T] = None  # Return data (on success)
    
    @classmethod
    def success(cls, message: str, data: T = None) -> "ApiResponse[T]":
        return cls(result="SUCCESS", message=message, data=data)
    
    @classmethod
    def error(cls, message: str) -> "ApiResponse[None]":
        return cls(result="ERROR", message=message, data=None)

# Router usage example
from fastapi import APIRouter, Depends, HTTPException

router = APIRouter(prefix="/api/accounts", tags=["accounts"])

@router.post("/create", response_model=ApiResponse[AccountResponse])
async def create_account(
    request: AccountRequest,
    account_service: AccountService = Depends(get_account_service)
) -> ApiResponse[AccountResponse]:
    try:
        account_dto = convert_to_dto(request)
        result = await account_service.create_account(account_dto)
        response = convert_to_response(result)
        
        return ApiResponse.success("Account created successfully.", response)
        
    except Exception as e:
        # Propagate to GlobalExceptionHandler for processing
        raise e

@router.get("/account/{account_no}", response_model=ApiResponse[AccountResponse])
async def get_account(
    account_no: str,
    account_service: AccountService = Depends(get_account_service)
) -> ApiResponse[AccountResponse]:
    # GlobalExceptionHandler handles all exceptions
    account = await account_service.get_account(account_no)
    return ApiResponse.success("Account retrieved successfully", convert_to_response(account))

@router.put("/account/{account_no}", response_model=ApiResponse[AccountResponse])
async def update_account(
    account_no: str,
    request: AccountUpdateRequest,
    account_service: AccountService = Depends(get_account_service)
) -> ApiResponse[AccountResponse]:
    # GlobalExceptionHandler handles all exceptions
    account_dto = convert_to_dto(request)
    updated_account = await account_service.update_account(account_no, account_dto)
    return ApiResponse.success("Account updated successfully", convert_to_response(updated_account))
```

# Exception Handling and Error Response

### GlobalExceptionHandler Extension

**Rule:** All exceptions are consistently handled by GlobalExceptionHandler

**Rationale:**
- Centralized error management
- Consistent API error response format
- Separation of error handling logic from business logic

#### Recommended Pattern: Consistent Exception Handling

```python
# common/exceptions.py
class BusinessException(Exception):
    # ...
# ... (other custom exceptions)

# main.py
def setup_exception_handlers(app: FastAPI):
    # ... (add custom exception handlers)
    
    # General exception handler for all other errors
    @app.exception_handler(Exception)
    async def general_exception_handler(request: Request, exc: Exception):
        # Log the exception details for debugging
        # logger.error(f"Unhandled exception: {exc}", exc_info=True)
        return JSONResponse(
            status_code=500,
            content=ApiResponse.error("An unexpected internal error occurred.").dict()
        )
```

This FastAPI backend design guideline is a conversion of Spring Boot guideline core principles adapted for the FastAPI environment.

**Key Conversion Points:**
1. **Spring Boot → FastAPI**: Dependency injection, routing, middleware
2. **JPA → SQLModel/SQLAlchemy**: ORM and database integration
3. **Java → Python**: Language-specific characteristics reflection
4. **Gradle → uv**: Package management tool

Would you like me to create the actual project structure based on these guidelines? 